<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      7.4.&nbsp;LFS 系统上的设备和模块管理
    </title>
    <link rel="stylesheet" href="../stylesheets/lfs.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
  </head>
  <body class="lfs" id="lfs-SVN-20121126">
    <div class="navheader">
      <h4>
        Linux From Scratch - 版本 SVN-20121126
      </h4>
      <h3>
        第&nbsp;7&nbsp;章&nbsp;设置系统引导脚本
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="hosts.html" title=
          "自定义 /etc/hosts 文件">上一页</a>
          <p>
            自定义 /etc/hosts 文件
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="symlinks.html" title="创建到设备的自定义符号链接">下一页</a>
          <p>
            创建到设备的自定义符号链接
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter07.html" title=
          "第&nbsp;7&nbsp;章&nbsp;设置系统引导脚本">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 SVN-20121126">起始页</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="zh-cn" xml:lang="zh-cn">
      <h1 class="sect1">
        <a id="ch-scripts-udev" name="ch-scripts-udev"></a>7.4. LFS
        系统上的设备和模块管理
      </h1>
      <p>
        在 <a class="xref" href="../chapter06/chapter06.html" title=
        "第&nbsp;6&nbsp;章&nbsp;安装基本系统软件">第六章</a> 中，我们安装了 Udev
        程序包。在我们了解它工作的具体原理前，读一段关于目前设备处理方法的简史。
      </p>
      <p>
        Linux 系统一般使用传统的静态设备创建方法，即在 <code class="filename">/dev</code>
        下创建大量设备节点 (有时候可达上千个) ，而无需考虑对应的硬件设备是否真实存在。这通常被通过一个 <span class=
        "command"><strong>MAKEDEV</strong></span> 脚本完成，该脚本包含 <span class=
        "command"><strong>mknod</strong></span>
        程序的调用次数以及每个可能存在与世界上的设备的相关主次设备编号。
      </p>
      <p>
        若使用 Udev 方法，只有那些被内核检测到的设备被创建设备节点。因为这些设备节点在每次系统引导时都会被创建，它们会被储存在
        <code class="systemitem">devtmpfs</code> 文件系统上
        (一个完全存在于系统内存上的虚拟文件系统)。设备节点不需要太多空间，因此被使用的内存是微不足道的。
      </p>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          7.4.1. 历史
        </h2>
        <p>
          2000 年二月，一个新的名为 <code class="systemitem">devfs</code> 的文件系统被混合到
          2.3.46 版本的内核中且在 2.4
          稳定版本的内核中可用。尽管现在它是内核源代码的一部分，这种创建动态设备的方法从未得到内核核心开发者的完全支持。
        </p>
        <p>
          <code class="systemitem">devfs</code>
          所采用方法的主要问题是它处理设备检测，创建和命名的方式。最后的问题，也就是设备节点命名，大概是最致命的。普遍接受的观点是，如果设备名称允许被配置，那么设备命名制度应当上传至一个系统管理员，且不因为任何特定的开发者而给他们带来麻烦。
          <code class="systemitem">devfs</code>
          系统文件同样受到其设计中固有的且无法不通过一次实质的内核改动修复的紊乱情况的困扰。它在相当长的一个时期中被标记为不宜使用 –
          由于缺乏维护 – 并且最终在 2006 年六月从内核中移除。
        </p>
        <p>
          随着对于不稳定的 2.5 内核源代码树的开发，在之后放出的 2.6 稳定版本中，一个新的虚拟文件系统 <code class=
          "systemitem">sysfs</code> 出现了。 <code class=
          "systemitem">sysfs</code> 的工作是输出一个系统硬件配置的预览到用户空间进程。通过这种用户空间可见的表示，
          <code class="systemitem">devfs</code> 得知某个用户空间替换的可能性的到了提高。
        </p>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          7.4.2. Udev 实现
        </h2>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.2.1. Sysfs
          </h3>
          <p>
            <code class="systemitem">sysfs</code> 文件系统在之前被简短地提到过。有人可能不明白
            <code class="systemitem">sysfs</code>
            如何得知设备正在一个系统中和它们应该使用的设备编号。被编译入内核的驱动在它们的对象被系统检测到时直接通过一个
            <code class="systemitem">sysfs</code> (本质上是 devmpfs)
            来注册。对于被编译为模块的驱动，该注册会在模块被加载时进行。一旦 <code class=
            "systemitem">sysfs</code> 文件系统被挂载 (on /sys)，驱动通过 <code class=
            "systemitem">sysfs</code> 注册的数据就可被用户空间进程使用和可被 udevd 处理
            (包括对设备节点的修改)。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.2.2. 设备节点创建
          </h3>
          <p>
            设备文件由内核通过 <code class="systemitem">devtmpfs</code>
            文件系统创建。任何想要注册一个设备节点的驱动将会通过 <code class=
            "systemitem">devtmpfs</code> (经由驱动内核) 来完成。当一个 <code class=
            "systemitem">devtmpfs</code> 实例被挂载到 <code class=
            "filename">/dev</code> ，设备节点将会以一个复合的名称，权限和所有权初始化。
          </p>
          <p>
            不久之后，内核会传递一个 uevent 到 <span class=
            "command"><strong>udevd</strong></span> 。基于由 <code class=
            "filename">/etc/udev/rules.d</code> ，<code class=
            "filename">/lib/udev/rules.d</code> 和 <code class=
            "filename">/run/udev/rules.d</code> 目录中的文件中的的具体规范， <span class=
            "command"><strong>udevd</strong></span>
            会创建额外的符号链接到设备节点或者改变其权限，所有者或组，或者修改对象的内部 <span class=
            "command"><strong>udevd</strong></span> 数据库入口 (名称)。
          </p>
          <p>
            这三个目录中的规范被用相近的方法编号到 LFS-Bootscripts 程序包且所有目录被混合到一起。如果
            <span class="command"><strong>udevd</strong></span>
            不能找到正在创建的设备的一个规范，它会使用任何 <code class="systemitem">devtmpfs</code>
            初始使用的权限和所有权。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.2.3. Udev 引导脚本
          </h3>
          <p>
            第一个 LFS 引导脚本 <code class=
            "filename">/etc/init.d/mountvirtfs</code> 会拷贝任何位于 <code class=
            "filename">/lib/udev/devices</code> 的设备到 <code class=
            "filename">/dev</code>
            。这很必要，因为一些设备，目录和符号链接在动态设备处理进程在系统引导的早期阶段中可用之前就被需要，或者被 <span class=
            "command"><strong>udevd</strong></span> 本身需求。在 <code class=
            "filename">/lib/udev/devices</code>
            中创建静态设备节点同样提供一个不被动态设备处理基础结构支持的简单工作区给设备。
          </p>
          <p>
            <code class="filename">/etc/rc.d/init.d/udev</code> initscript 启动
            <span class="command"><strong>udevd</strong></span>
            ，使得任何已有内核创建并在等候某一规范的 "冷插拔" 设备完成。脚本同样将 uevent 处理器从 <code class=
            "filename">/sbin/hotplug</code>
            的默认值解除设置。这样做事因为内核不再需要调用一个外接二进制。取而代之地， <span class=
            "command"><strong>udevd</strong></span> 将会为内核调用的 uevents 监听一个
            netlink 套接字。
          </p>
          <p>
            <span class=
            "command"><strong>/etc/rc.d/init.d/udev_retry</strong></span>
            initscript 为其规范可能依赖在 <span class=
            "command"><strong>mountfs</strong></span> 脚本运行之前 (特别地，
            <code class="filename">/usr</code> 和 <code class=
            "filename">/var</code> 可能造成该情况) 未被挂载的文件系统的子系统关注重触发事件。该脚本在
            <span class="command"><strong>mountfs</strong></span>
            脚本之后运行，所以那些规范 (如果被重触发) 应该在下一次成功。它从 <code class=
            "filename">/etc/sysconfig/udev_retry</code>
            文件被配置；这个文件中的任何除注释外的文字被认为是重试时要触发的子系统名称。要找到一个设备的子系统，使用 <span class=
            "command"><strong>udevadm info --attribute-walk
            &lt;device&gt;</strong></span> ，&lt;device&gt; 是一个在 /dev 或 /sys
            中的绝对路径例如 /dev/sr0 或 /sys/class/rtctakes。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.2.4. 模块加载
          </h3>
          <p>
            作为模块编译的设备驱动可能在内部编制了别名。别名可以在 <span class=
            "command"><strong>modinfo</strong></span>
            程序的输出中看到并且通常与由一个模块支持的按总线指定的设备标识符相关。例如， <span class=
            "emphasis"><em>snd-fm801</em></span> 驱动支持生产商 ID 0x1319 和设备 ID
            0x0801 的 PCI 设备，并且有一个别名为 “<span class=
            "quote">pci:v00001319d00000801sv*sd*bc04sc01i*</span>”
            。对多数设备来说，总线驱动经由 <code class="systemitem">sysfs</code>
            输出将要处理设备的驱动的别名。例如，<code class=
            "filename">/sys/bus/pci/devices/0000:00:0d.0/modalias</code>
            文件可能包含字符串 “<span class=
            "quote">pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</span>”
            。Udev 提供的默认规范会使 <span class=
            "command"><strong>udevd</strong></span> 用 <code class=
            "envar">MODALIAS</code> uevent 环境变量 (应当与 sysfs 中的 <code class=
            "filename">modalias</code> 的文件内容相同) 调用 <span class=
            "command"><strong>/sbin/modprobe</strong></span>
            ，这样就可以在通配符扩展之加载所有别名与该字符串对应的模块。
          </p>
          <p>
            这个例子中，意味着除 <span class="emphasis"><em>snd-fm801</em></span> 外，废弃
            (且不需要) 的 <span class="emphasis"><em>forte</em></span>
            驱动若可用则被加载。往下阅读避免不需要的驱动被加载的方法。
          </p>
          <p>
            内核本身也可以为要求的网络协议，文件系统和 NLS 支持加载模块。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.2.5. 处理 可热插拔/动态 设备
          </h3>
          <p>
            当你插入一个设备，比如一个通用串行总线 (USB) MP3 播放器，内核辨认出该设备现已连接并生成一个 uevent。这个
            uevent 之后被 <span class="command"><strong>udevd</strong></span>
            按上述方法处理。
          </p>
        </div>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          7.4.3. 加载模块和创建设备时的问题
        </h2>
        <p>
          当自动创建设备节点时可能出现一些问题。
        </p>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.3.1. 一个内核模块未被自动加载
          </h3>
          <p>
            Udev 只会在它有一个给定总线的别名且总线驱动正确输出必要的别名到 <code class=
            "systemitem">sysfs</code> 时加载该模块。其他情况下，需要通过其他途径安排模块加载。对于
            Linux-3.6.7 ，Udev 可以为 INPUT，IDE， PCI，USB，SCSI，SERIO 和 FireWire
            设备加载正确编写的驱动。
          </p>
          <p>
            要决定你需要的设备驱动有对 Udev 必须的支持，以模块名称参数运行 <span class=
            "command"><strong>modinfo</strong></span> 。现在尝试定位设备目录到
            <code class="filename">/sys/bus</code> 下并且检查这里是否有一个 <code class=
            "filename">modalias</code> 文件。
          </p>
          <p>
            如果 <code class="filename">modalias</code> 文件存在于 <code class=
            "systemitem">sysfs</code> 中，驱动支持设备并且可以直接与其交互，但不拥有别名，这是驱动中的一个 bug
            。不借助 Udev 加载驱动，这一问题应当会在之后被修复。
          </p>
          <p>
            如果在 <code class="filename">/sys/bus</code> 下的相对目录中没有 <code class=
            "filename">modalias</code> 文件，这意味着内核开发者还未添加对该总线类型的 modalias 支持。对于
            Linux-3.6.7 ，这是涉及 ISA 总线时的情况。这一问题应当在之后的内核版本中被修复。
          </p>
          <p>
            Udev 完全不打算加载 “<span class="quote">wrapper</span>” 驱动例如
            <span class="emphasis"><em>snd-pcm-oss</em></span> 和非硬件驱动例如
            <span class="emphasis"><em>loop</em></span>。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.3.2. 一个内核模块未被自动加载，且 Udev 不打算加载它
          </h3>
          <p>
            如果 “<span class="quote">wrapper</span>” 模块只改善了一些其他模块提供的功能 (例如
            <span class="emphasis"><em>snd-pcm-oss</em></span> 通过使声卡对 OSS
            应用可用改善了 <span class="emphasis"><em>snd-pcm</em></span> 的功能) ，配置
            <span class="command"><strong>modprobe</strong></span> 来在Udev加载
            warpped 模块之后加载 wrapper 。要这样做，添加一行 “<span class=
            "quote">softdep</span>” 到任何 <code class=
            "filename">/etc/modprobe.d/<em class=
            "replaceable"><code>&lt;filename&gt;</code></em>.conf</code>
            文件。例如：
          </p>
          <pre class="screen">
<code class="literal">softdep snd-pcm post: snd-pcm-oss</code>
</pre>
          <p>
            注意 “<span class="quote">softdep</span>” 命令同样允许 <code class=
            "literal">pre:</code> 依赖关系，或 <code class="literal">pre:</code> 和
            <code class="literal">post:</code> 二者的一个混合。查阅 <code class=
            "filename">modprobe.d(5)</code> 手册页来获取更多有关 “<span class=
            "quote">softdep</span>” 语法和兼容性的信息。
          </p>
          <p>
            如果被操作的模块不是一个 wrapper 模块且可被自身使用，配置 <span class=
            "command"><strong>modules</strong></span>
            引导脚本来加载这个模块到系统引导上。要如此做，添加模块名称到 <code class=
            "filename">/etc/sysconfig/modules</code> 文件的一条独立行上。这同样对 wrapper
            模块有效，但对于这种情况并不理想。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.3.3. Udev 加载了一些不需要的模块
          </h3>
          <p>
            不编制该模块或将其拖入 <code class=
            "filename">/etc/modprobe.d/blacklist.conf</code> 下的黑名单。下面提供了对
            <span class="emphasis"><em>forte</em></span> 模块进行该操作的例子：
          </p>
          <pre class="screen">
<code class="literal">blacklist forte</code>
</pre>
          <p>
            拖入黑名单的模块仍然可以由明确的 <span class=
            "command"><strong>modprobe</strong></span> 命令手动加载。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.3.4. Udev 不正确地创建了一个设备或做了一个错误的符号链接
          </h3>
          <p>
            这通常在某个规范错误地对应到一个设备上时发生。例如，一个编写得极糟糕的规范可以同时对应到一个 SCSI 盘 (所期望地)
            和按生产商匹配到对应的 SCSI 泛设备 (不正确地) 。找到冲突的规范并借助 <span class=
            "command"><strong>udevadm info</strong></span> 命令来让它更为确切。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.3.5. Udev 规范不能可靠工作
          </h3>
          <p>
            这可能是先前问题的另一种表现。如果不是，且你的规范使用 <code class="systemitem">sysfs</code>
            属性，它可能是一个内核计时错误，会在之后的内核版本中被修复。目前，你可以通过创建一个等待被使用的 <code class=
            "systemitem">sysfs</code> 属性的规范并且将其添加到 <code class=
            "filename">/etc/udev/rules.d/10-wait_for_sysfs.rules</code> 文件
            (若该文件不存在，创建它) 来正常工作。请通知 LFS 开发列表如果你如此做且成功了。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.3.6. Udev 不创建一个设备
          </h3>
          <p>
            进一步的的文本内容默认驱动被静态编制到内核中或已经被作为模块加载，且你已经检查过 Udev 没有创建一个名称错误的设备。
          </p>
          <p>
            如果内核驱动不输出它的数据到 <code class="systemitem">sysfs</code> ，Udev
            将没有所需要的信息来创建一个设备。这在位于内核树外的第三方驱动中尤为常见。以合适的主/次号 (查阅内核文件中的
            <code class="filename">devices.txt</code> 或由第三方驱动生产商提供的文件)
            创建一个静态设备节点于 <code class="filename">/lib/udev/devices</code>
            。该静态设备节点会被 <span class="command"><strong>udev</strong></span>
            驱动脚本拷贝到 <code class="filename">/dev</code>
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            7.4.3.7. 设备命名顺序在重引导后随机改变
          </h3>
          <p>
            这是因为一个事实：Udev 在设计时并行地处理 uevents 和加载模块，于是产生无法预测的顺序。这永远不可能被
            “<span class="quote">修复</span>”
            。你不应当期望内核设备命名具有稳定性。取而代之地，创建你自己的规范来以基于设备的一些稳定属性的稳定命名制作符号链接，例如一个序列号或各个由
            Udev 安装的 *_id 工具的输出。查阅 <a class="xref" href="symlinks.html"
            title="7.5.&nbsp;创建到设备的自定义符号链接">第&nbsp;7.5&nbsp;节
            “创建到设备的自定义符号链接”</a> 和 <a class="xref" href="network.html" title=
            "7.2.&nbsp;通用网络配置">第&nbsp;7.2&nbsp;节 “通用网络配置”</a> 来获得资料。
          </p>
        </div>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          7.4.4. 有用的内容
        </h2>
        <p>
          额外的帮助文件在以下站点可以得到：
        </p>
        <div class="itemizedlist">
          <ul>
            <li>
              <p>
                一种用户空间下 <code class="systemitem">devfs</code> 的实现 <a class=
                "ulink" href=
                "http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf">
                http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf</a>
              </p>
            </li>
            <li>
              <p>
                <code class="systemitem">sysfs</code> 文件系统 <a class="ulink"
                href=
                "http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf">
                http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf</a>
              </p>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="hosts.html" title=
          "自定义 /etc/hosts 文件">上一页</a>
          <p>
            自定义 /etc/hosts 文件
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="symlinks.html" title="创建到设备的自定义符号链接">下一页</a>
          <p>
            创建到设备的自定义符号链接
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter07.html" title=
          "第&nbsp;7&nbsp;章&nbsp;设置系统引导脚本">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 SVN-20121126">起始页</a>
        </li>
      </ul>
    </div>
  </body>
</html>
