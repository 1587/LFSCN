<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      5.2.&nbsp;工具链技术注记
    </title>
    <link rel="stylesheet" href="../stylesheets/lfs.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
  </head>
  <body class="lfs" id="lfs-SVN-20121015">
    <div class="navheader">
      <h4>
        Linux From Scratch - 版本 SVN-20121015
      </h4>
      <h3>
        第&nbsp;5&nbsp;章&nbsp;搭建临时系统
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="introduction.html" title="介绍">上一页</a>
          <p>
            介绍
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="generalinstructions.html" title=
          "通用编译指令">下一页</a>
          <p>
            通用编译指令
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter05.html" title=
          "第&nbsp;5&nbsp;章&nbsp;搭建临时系统">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 SVN-20121015">起始页</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="zh-cn" xml:lang="zh-cn">
      <h1 class="sect1">
        <a id="ch-tools-toolchaintechnotes" name=
        "ch-tools-toolchaintechnotes"></a>5.2. 工具链技术注记
      </h1>
      <p>
        这一节解释总体编制方法的某些基本原理和技术细节。不必立刻理解其中所有内容。大部分信息会在进行实际编制之后变得清晰，在此过程中可以随时查阅。
      </p>
      <p>
        <a class="xref" href="chapter05.html" title=
        "第&nbsp;5&nbsp;章&nbsp;搭建临时系统">第五章</a>
        的总体目的是产生一个临时区域，要包含已知可用的、能从宿主独立出来的工具集。通过使用 <span class=
        "command"><strong>chroot</strong></span>，余下章节中的命令就会被限制在此环境内，确保目标 LFS
        系统编制干净而且没有麻烦。编制进程按照最小化新读者风险并同时提供最大的教育价值设计。
      </p>
      <div class="admon note">
        <img alt="[注意]" src="../images/note.png" />
        <h3>
          注意
        </h3>
        <p>
          在继续之前，注意工作平台的名字，也叫做目标三联字串。获知目标三联字串的简单方法是运行 <span class=
          "command"><strong>config.guess</strong></span> 脚本，它随很多程序包的源代码出现。解包
          Binutils 源代码并运行脚本：<strong class=
          "userinput"><code>./config.guess</code></strong> 并注意输出。举个例子，对于一个现代的
          32 位英特尔处理器来说输出可能会是 <code class=
          "computeroutput">i686-pc-linux-gnu</code>。
        </p>
        <p>
          也要注意平台的动态链接器名称，通常叫做动态加载器 (以防与作为 Binutils 的一部分的标准链接器 <span class=
          "command"><strong>ld</strong></span> 混淆)。动态链接器由 Glibc
          提供，会寻找并加载程序需要的共享库，准备并运行程序。32 位英特尔处理器使用的动态链接器名应为 <code class=
          "filename">ld-linux.so.2</code>。在宿主系统中随意查看一个二进制就可以获知动态链接器名：<strong class="userinput"><code>readelf
          -l &lt;binary&gt; | grep interpreter</code></strong>
          留意其输出。官方的覆盖了所有平台的参考位于 Glibc 源代码树中的 <code class=
          "filename">shlib-versions</code> 文件中。
        </p>
      </div>
      <p>
        有关 <a class="xref" href="chapter05.html" title=
        "第&nbsp;5&nbsp;章&nbsp;搭建临时系统">第五章</a> 中的编制方法如何工作的一些核心技术要点如下：
      </p>
      <div class="itemizedlist">
        <ul>
          <li>
            <p>
              轻微调整工作平台名，通过 <code class="envar">LFS_TGT</code> 变量改变 "生产商"
              字段以确保首次编制的 Binutils 和 GCC
              能产生兼容的交叉编译器和交叉链接器。交叉编译器和交叉链接器将会产生与当前硬件兼容的二进制而不会产生另一个架构的二进制。
            </p>
          </li>
          <li>
            <p>
              临时库是交叉编译的。因为交叉编译器自然无法依赖宿主系统上的任何东西，这就减少了头文件和库从宿主被包含至新工具的可能，进而防止了对目标系统的潜在污染。交叉编译也允许在
              64 位兼容的硬件上既编译 32 位库也编译 64 位库。
            </p>
          </li>
          <li>
            <p>
              小心地对 <span class="command"><strong>gcc</strong></span>
              的源代码进行操作，以告知编译器应该使用哪个目标动态链接器。
            </p>
          </li>
        </ul>
      </div>
      <p>
        Binutils 要首先安装，因为 GCC 和 Glibc 的 <span class=
        "command"><strong>configure</strong></span>
        在运行时都会对汇编器和链接器进行特性测试来决定要启用还是禁用他们自己的每个特性。这比你一开始意识到的要重要。配置不正确的 GCC 或
        Glibc
        会导致工具链轻微破损，而这样的破损可能在整个发行版编制接近尾声之前都不会体现出来。在完成太多额外工作之前，某一个测试套件不能通过会指出此错误。
      </p>
      <p>
        Binutils 安装汇编器和链接器到两个位置：<code class="filename">/tools/bin</code> 和
        <code class=
        "filename">/tools/$LFS_TGT/bin</code>。两个位置的工具之间是硬链接。链接器很重要的一点是库搜索顺序。相关信息可以通过传递
        <em class="parameter"><code>--verbose</code></em> 给 <span class=
        "command"><strong>ld</strong></span> 来获取。比如 <strong class=
        "userinput"><code>ld --verbose | grep SEARCH</code></strong>
        就会按顺序列出当前的搜索路径。通过编译一个伪程序并给链接器传递一个 <em class=
        "parameter"><code>--verbose</code></em> 开关可以显示哪些文件被 <span class=
        "command"><strong>ld</strong></span> 链接。比如 <strong class=
        "userinput"><code>gcc dummy.c -Wl,--verbose 2&gt;&amp;1 | grep
        succeeded</code></strong> 会显示链接过程中成功打开的所有文件。
      </p>
      <p>
        下一个安装的程序包是 GCC。它的 <span class=
        "command"><strong>configure</strong></span> 运行时能看到的一例输出为：
      </p>
      <pre class="screen">
<code class=
"computeroutput">checking what assembler to use... /tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /tools/i686-lfs-linux-gnu/bin/ld</code>
</pre>
      <p>
        由于上面提到的原因，这很重要。这也显示了 GCC 的配置脚本不会搜索 PATH 目录来查找要使用的工具。然而，在实际操作
        <span class="command"><strong>gcc</strong></span> 时，同样的搜索路径不必使用。要查看
        <span class="command"><strong>gcc</strong></span>
        要使用的标准链接器，运行：<strong class="userinput"><code>gcc
        -print-prog-name=ld</code></strong>。
      </p>
      <p>
        详细信息可以通过在编译伪程序时传递 <em class="parameter"><code>-v</code></em> 命令行选项给
        <span class="command"><strong>gcc</strong></span>
        来获取。比如，<strong class="userinput"><code>gcc -v dummy.c</code></strong>
        就会显示关于预处理器、编译和汇编步骤的详细信息，包括 <span class=
        "command"><strong>gcc</strong></span> 的搜索路径和顺序。
      </p>
      <p>
        下一个安装的是净化的 Linux API 头文件。它们允许标准 C 库 (Glibc) 与 Linux 内核将会提供的特性交互。
      </p>
      <p>
        接下来安装的程序包是 Glibc。编制 Glibc 是最重要的是要考虑到编译器、二进制工具和内核头文件。编译器通常不是问题，因为
        Glibc 会总是使用与传递给它的配置脚本的 <em class="parameter"><code>--host</code></em>
        参数相关的编译器，在我们的例子中是 <span class=
        "command"><strong>i686-lfs-linux-gnu-gcc</strong></span>。二进制工具和内核头文件就有一点复杂了。所以，不要冒险，使用可用的配置开关来强制正确的选择。运行
        <span class="command"><strong>configure</strong></span> 之后，检查
        <code class="filename">glibc-build</code> 目录中的 <code class=
        "filename">config.make</code> 文件来查看所有重要的细节。注意使用 <em class=
        "parameter"><code>CC="i686-lfs-gnu-gcc"</code></em> 来控制要使用的二进制工具，并用
        <em class="parameter"><code>-nostdinc</code></em> 和 <em class=
        "parameter"><code>-isystem</code></em> 标记来控制编译器的包含搜索路径。这些事项就是 Glibc
        的要点——它在编制机理上非常自我高效，通常不会依赖工具链默认设置。
      </p>
      <p>
        安装 Glibc 之后，改变 <span class="command"><strong>gcc</strong></span> 的
        specs 文件指向位于 <code class="filename">/tools/lib</code>
        的新的动态链接器。这最后一步对于确保搜索和链接在 <code class="filename">/tools</code>
        前缀之内进行非常关键。在每一个 ELF 格式的可执行文件中都嵌入了动态链接器的不可改变的路径。可以这样查看：<strong class=
        "userinput"><code>readelf -l &lt;name of binary&gt; | grep
        interpreter</code></strong>。修改 <span class=
        "command"><strong>gcc</strong></span> 的 specs
        文件确保从这里到本章末编译的所有文件都会使用位于 <code class="filename">/tools/lib</code>
        的新的动态链接器。
      </p>
      <p>
        在第二遍编译 Binutils 时，我们就可以利用 <em class=
        "parameter"><code>--with-lib-path</code></em> 配置开关来控制 <span class=
        "command"><strong>ld</strong></span> 的库搜索路径了。
      </p>
      <p>
        对于第二遍编译 GCC，也许要修改源代码来让 GCC 使用新的动态链接器。若不能如此做，GCC 程序就会嵌入宿主系统
        <code class="filename">/lib</code>
        目录中动态链接器的路径，离开宿主的目标也就无法实现。从这里开始，核心工具链就以本身为容器和宿主了。<a class="xref"
        href="chapter05.html" title="第&nbsp;5&nbsp;章&nbsp;搭建临时系统">第五章</a>
        余下的程序包都依照 <code class="filename">/tools</code> 中新的 Glibc 编译。
      </p>
      <p>
        在 <a class="xref" href="../chapter06/chapter06.html" title=
        "第&nbsp;6&nbsp;章&nbsp;安装基本系统软件">第六章</a> 进入 <span class=
        "command"><strong>chroot</strong></span> 环境时，第一个安装的主要程序包就是
        Glibc，原因就是上面提到过的自我高效的特性。一旦这个 Glibc 安装到 <code class=
        "filename">/usr</code>，我们就要调节工具链默认设置，然后继续编制目标 LFS 系统的余下部分。
      </p>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="introduction.html" title="介绍">上一页</a>
          <p>
            介绍
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="generalinstructions.html" title=
          "通用编译指令">下一页</a>
          <p>
            通用编译指令
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter05.html" title=
          "第&nbsp;5&nbsp;章&nbsp;搭建临时系统">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 SVN-20121015">起始页</a>
        </li>
      </ul>
    </div>
  </body>
</html>
