<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      5.10.&nbsp;GCC-4.7.0 - 第二遍
    </title>
    <link rel="stylesheet" href="../stylesheets/lfs.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
  </head>
  <body class="lfs" id="lfs-SVN-20120328">
    <div class="navheader">
      <h4>
        Linux From Scratch - 版本 SVN-20120328
      </h4>
      <h3>
        第&nbsp;5&nbsp;章&nbsp;搭建临时系统
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="binutils-pass2.html" title=
          "Binutils-2.22 - 第二遍">上一页</a>
          <p>
            Binutils-2.22 - 第二遍
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="tcl.html" title="Tcl-8.5.11">下一页</a>
          <p>
            Tcl-8.5.11
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter05.html" title=
          "第&nbsp;5&nbsp;章&nbsp;搭建临时系统">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 SVN-20120328">起始页</a>
        </li>
      </ul>
    </div>
    <div class="wrap" lang="zh-cn" xml:lang="zh-cn">
      <h1 class="sect1">
        <a id="ch-tools-gcc-pass2" name="ch-tools-gcc-pass2"></a>5.10.
        GCC-4.7.0 - 第二遍
      </h1>
      <div class="package" lang="zh-cn" xml:lang="zh-cn">
        <p>
          GCC 程序包包含 GNU 编译器集，其中包括 C 和 C++ 编译器。
        </p>
        <div class="segmentedlist">
          <div class="seglistitem">
            <div class="seg">
              <strong class="segtitle">预计编制时间:</strong> <span class=
              "segbody">7.0 SBU</span>
            </div>
            <div class="seg">
              <strong class="segtitle">需求磁盘空间:</strong> <span class=
              "segbody">1.5 GB</span>
            </div>
          </div>
        </div>
      </div>
      <div class="installation" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          5.10.1. 安装 GCC
        </h2>
        <p>
          晚于 4.3 版本的 GCC 会将此次编制作为重新定位编译器来对待，不会允许在 <em class=
          "parameter"><code>--prefix</code></em> 指定的位置搜索起始文件。由于这不是重新定位编译器，而
          <code class="filename">/tools</code> 中的起始文件对于编制一个链接至 <code class=
          "filename">/tools</code> 中的库的编译器至关重要，所以应用以下补丁暂时将 GCC 还原到旧的行为：
        </p>
        <pre class="userinput">
<kbd class="command">patch -Np1 -i ../gcc-4.7.0-startfiles_fix-1.patch</kbd>
</pre>
        <p>
          通常情况下 GCC <span class="command"><strong>fixincludes</strong></span>
          脚本会被运行，来修复潜在损坏的头文件。由于现在 GCC-4.7.0 和 Glibc-2.15
          已经安装好了，它们的头文件都已知不需要修复，就不需要运行 <span class=
          "command"><strong>fixincludes</strong></span>
          脚本。事实上，运行这个脚本可能会从宿主系统向 GCC 的私有包含目录安装修复的头文件而污染编制环境。可以执行以下命令来支持运行
          <span class="command"><strong>fixincludes</strong></span> 脚本：
        </p>
        <pre class="userinput">
<kbd class="command">cp -v gcc/Makefile.in{,.orig}
sed 's@\./fixinc\.sh@-c true@' gcc/Makefile.in.orig &gt; gcc/Makefile.in</kbd>
</pre>
        <p>
          对于 x86 计算机，引导编制 GCC 使用 <code class=
          "option">-fomit-frame-pointer</code>
          编译器标记。非引导编制默认会忽略这个标记，而我们的目标是产生一个和引导过完全一样的编译器。应用以下的 <span class=
          "command"><strong>sed</strong></span> 命令强制编制使用这个标记：
        </p>
        <pre class="userinput">
<kbd class="command">cp -v gcc/Makefile.in{,.tmp}
sed 's/^T_CFLAGS =$/&amp; -fomit-frame-pointer/' gcc/Makefile.in.tmp \
  &gt; gcc/Makefile.in</kbd>
</pre>
        <p>
          以下命令将改变 GCC 的默认动态链接器位置以使用安装于 <code class="filename">/tools</code>
          的那一个。它也会从 GCC 的包含搜索路径中移除 <code class=
          "filename">/usr/include</code>。现在就这样做而不是安装后调节 specs 文件是为了确保实际编制 GCC
          的过程中使用新的动态链接器。执行：
        </p>
        <pre class="userinput">
<kbd class="command">for file in \
 $(find gcc/config -name linux64.h -o -name linux.h -o -name sysv4.h)
do
  cp -uv $file{,.orig}
  sed -e 's@/lib\(64\)\?\(32\)\?/ld@/tools&amp;@g' \
  -e 's@/usr@/tools@g' $file.orig &gt; $file
  echo '
#undef STANDARD_STARTFILE_PREFIX_1
#undef STANDARD_STARTFILE_PREFIX_2
#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib"
#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file
  touch $file.orig
done</kbd>
</pre>
        <p>
          由于上文似乎很难跟进，我们把它拆解开来。首先我们找到 <code class="filename">gcc/config</code>
          目录中所有名为 <code class="filename">linux.h</code>、<code class=
          "filename">linux64.h</code> 或者 <code class=
          "filename">sysv4.h</code> 的文件。对于找到的每个文件，我们把它复制为一个有同样名字但是加上
          “<span class="quote">.orig</span>” 后缀。然后第一个 sed 表达式将出现的所有
          “<span class="quote">/lib/ld</span>”、“<span class=
          "quote">/lib64/ld</span>” 或 “<span class="quote">/lib32/ld</span>”
          替换为 “<span class="quote">/tools</span>”，第二个替换硬编码的 “<span class=
          "quote">/usr</span>”。然后我们在文件末尾添加我们的声明，调节包含搜索路径和起始文件前缀。最后我们用
          <span class="command"><strong>touch</strong></span> 来更新复制的文件的时间戳。在与
          <span class="command"><strong>cp -u</strong></span>
          联用时这可以防止由于误操作将命令运行两次而改变原有文件。
        </p>
        <p>
          在 x86_64 上，给 GCC 解除多重库 specs 可以确保它不会试图链接至宿主上的库：
        </p>
        <pre class="userinput">
<kbd class="command">case $(uname -m) in
  x86_64)
    for file in $(find gcc/config -name t-linux64) ; do \
      cp -v $file{,.orig}
      sed '/MULTILIB_OSDIRNAMES/d' $file.orig &gt; $file
    done
  ;;
esac</kbd>
</pre>
        <p>
          与第一次编译 GCC 相同，它需要 GMP、MPFR 和 MPC 程序包。解开压缩包冰将它们移动到指定名称的目录中：
        </p>
        <pre class="userinput">
<kbd class="command">tar -jxf ../mpfr-3.1.0.tar.bz2
mv -v mpfr-3.1.0 mpfr
tar -Jxf ../gmp-5.0.4.tar.xz
mv -v gmp-5.0.4 gmp
tar -zxf ../mpc-0.9.tar.gz
mv -v mpc-0.9 mpc</kbd>
</pre>
        <p>
          再创建一个独立的编制目录：
        </p>
        <pre class="userinput">
<kbd class="command">mkdir -v ../gcc-build
cd ../gcc-build</kbd>
</pre>
        <p>
          在开始编制 GCC 之前，记得解除所有覆盖默认调节标记的环境变量。
        </p>
        <p>
          现在准备编译 GCC：
        </p>
        <pre class="userinput">
<kbd class="command">CC="$LFS_TGT-gcc -B/tools/lib/" \
AR=$LFS_TGT-ar                  \
RANLIB=$LFS_TGT-ranlib          \
../gcc-4.7.0/configure          \
    --prefix=/tools             \
    --with-local-prefix=/tools  \
    --enable-clocale=gnu        \
    --enable-shared             \
    --enable-threads=posix      \
    --enable-__cxa_atexit       \
    --enable-languages=c,c++    \
    --disable-libstdcxx-pch     \
    --disable-multilib          \
    --disable-bootstrap         \
    --disable-libgomp           \
    --without-ppl               \
    --without-cloog             \
    --with-mpfr-include=$(pwd)/../gcc-4.7.0/mpfr/src \
    --with-mpfr-lib=$(pwd)/mpfr/src/.libs</kbd>
</pre>
        <div class="variablelist">
          <p class="title">
            <b>新配置脚本的含义：</b>
          </p>
          <dl>
            <dt>
              <span class="term"><em class=
              "parameter"><code>--enable-clocale=gnu</code></em></span>
            </dt>
            <dd>
              <p>
                此选项确保在任何情况下都能给 C++ 库选择正确的区域数据模型。如果配置脚本发现安装了 <span class=
                "emphasis"><em>de_DE</em></span> 区域数据，它就会选择正确的 gnu
                区域数据模型。但是如果 <span class="emphasis"><em>de_DE</em></span>
                区域数据没有安装，就有可能因为选中了不正确的通用区域数据模型而编制出与 ABI 不兼容的 C++ 库。
              </p>
            </dd>
            <dt>
              <span class="term"><em class=
              "parameter"><code>--enable-threads=posix</code></em></span>
            </dt>
            <dd>
              <p>
                此项启用 C++ 多线程代码的异常处理。
              </p>
            </dd>
            <dt>
              <span class="term"><em class=
              "parameter"><code>--enable-__cxa_atexit</code></em></span>
            </dt>
            <dd>
              <p>
                此选项允许使用 <code class="function">__cxa_atexit</code> 而不是
                <code class="function">atexit</code> 来本地静态和全局对象注册 C++
                析构函数。此选项对于完全兼容标准的析构函数处理是必要的。它也会影响 C++ ABI，而使得 C++ 程序和共享库可以与其他
                Linux 发行版相互操作。
              </p>
            </dd>
            <dt>
              <span class="term"><em class=
              "parameter"><code>--enable-languages=c,c++</code></em></span>
            </dt>
            <dd>
              <p>
                此选项确保 C 和 C++ 编译器都被编制。
              </p>
            </dd>
            <dt>
              <span class="term"><em class=
              "parameter"><code>--disable-libstdcxx-pch</code></em></span>
            </dt>
            <dd>
              <p>
                不要给 <code class="filename">libstdc++</code>
                编制预编译头文件。它占用很多空间，对我们还没有用。
              </p>
            </dd>
            <dt>
              <span class="term"><em class=
              "parameter"><code>--disable-bootstrap</code></em></span>
            </dt>
            <dd>
              <p>
                对于原生 GCC 编制，默认会进行 “引导” 编制。这不是只编译
                GCC，而是编译它几遍。用第一次编译的程序把自己编译第二遍，然后编译第三遍。然后比较第二遍和第三遍的产物以确保它可以不出差错地自编译。这也就表示它编译正确。然而，LFS
                编制方法会提供一个固化的编译器，不用每次都引导。
              </p>
            </dd>
          </dl>
        </div>
        <p>
          编译程序包：
        </p>
        <pre class="userinput">
<kbd class="command">make</kbd>
</pre>
        <p>
          安装程序包：
        </p>
        <pre class="userinput">
<kbd class="command">make install</kbd>
</pre>
        <p>
          最后一步，创建一个符号链接。很多程序和脚本会运行 <span class=
          "command"><strong>cc</strong></span> 而不是 <span class=
          "command"><strong>gcc</strong></span>，用来使程序通用，在所有的 UNIX 系统上都可用，而
          GNU 编译器并不总是安装。运行 <span class="command"><strong>cc</strong></span>
          就给系统管理员留出了选择安装哪一个 C 编译器的自由：
        </p>
        <pre class="userinput">
<kbd class="command">ln -vs gcc /tools/bin/cc</kbd>
</pre>
        <div class="admon caution">
          <img alt="[小心]" src="../images/caution.png" />
          <h3>
            小心
          </h3>
          <p>
            在这里，停下来确保新工具链的基本功能 (编译和链接) 能正常工作很重要。要进行完整性检查，运行以下命令：
          </p>
          <pre class="userinput">
<kbd class="command">echo 'main(){}' &gt; dummy.c
cc dummy.c
readelf -l a.out | grep ': /tools'</kbd>
</pre>
          <p>
            果一切工作正常，就不会出现错误，最后一条命令的输出会符合以下格式：
          </p>
          <pre class="screen">
<code class=
"computeroutput">[Requesting program interpreter: /tools/lib/ld-linux.so.2]</code>
</pre>
          <p>
            留意 <code class="filename">/tools/lib</code> 或者 64 位计算机上的
            <code class="filename">/tools/lib64</code> 作为动态链接器的前缀出现。
          </p>
          <p>
            如果输出不如上文所示或者根本没有输出，那就有什么地方出错了。研究回溯刚才的步骤，查出问题并修正它。在继续之前必须解决这一问题。首先，使用
            <span class="command"><strong>gcc</strong></span> 而不是
            <span class="command"><strong>cc</strong></span>
            再做一次完整性检查。如果能够工作，那就是 <code class="filename">/tools/bin/cc</code>
            这个符号链接丢失了。重做这个链接。下一步，确保 <code class="envar">PATH</code> 正确。可以运行
            <span class="command"><strong>echo $PATH</strong></span> 并检查
            <code class="filename">/tools/bin</code> 是否在列表首位。如果 <code class=
            "envar">PATH</code> 错误可能就是你未作为 <code class=
            "systemitem">lfs</code> 用户登录或者早在<a class="xref" href=
            "../chapter04/settingenvironment.html" title=
            "4.4.&nbsp;设置工作环境">第&nbsp;4.4&nbsp;节 “设置工作环境”</a>就出现了错误。
          </p>
          <p>
            一切正常之后，清理测试文件：
          </p>
          <pre class="userinput">
<kbd class="command">rm -v dummy.c a.out</kbd>
</pre>
        </div>
      </div>
      <div class="content" lang="zh-cn" xml:lang="zh-cn">
        <p>
          有关此程序包的细节位于<a class="xref" href=
          "../chapter06/gcc.html#contents-gcc" title=
          "6.17.2.&nbsp;GCC 的内容">第&nbsp;6.17.2&nbsp;节 “GCC 的内容”</a>。
        </p>
      </div>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="binutils-pass2.html" title=
          "Binutils-2.22 - 第二遍">上一页</a>
          <p>
            Binutils-2.22 - 第二遍
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="tcl.html" title="Tcl-8.5.11">下一页</a>
          <p>
            Tcl-8.5.11
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter05.html" title=
          "第&nbsp;5&nbsp;章&nbsp;搭建临时系统">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 SVN-20120328">起始页</a>
        </li>
      </ul>
    </div>
  </body>
</html>
