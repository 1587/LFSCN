<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-tools-gcc-pass2" role="wrap">
  <?dbhtml filename="gcc-pass2.html"?>

  <sect1info condition="script">
    <productname>gcc</productname>
    <productnumber>&gcc-version;</productnumber>
    <address>&gcc-url;</address>
  </sect1info>

  <title>GCC-&gcc-version; - 第二遍</title>

  <indexterm zone="ch-tools-gcc-pass2">
    <primary sortas="a-GCC">GCC</primary>
    <secondary>工具、第二遍</secondary>
  </indexterm>

  <sect2 role="package">
    <title/>

    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
    href="../chapter06/gcc.xml"
    xpointer="xpointer(/sect1/sect2[1]/para[1])"/>

    <segmentedlist>
      <segtitle>&buildtime;</segtitle>
      <segtitle>&diskspace;</segtitle>

      <seglistitem>
        <seg>&gcc-ch5p2-sbu;</seg>
        <seg>&gcc-ch5p2-du;</seg>
      </seglistitem>
    </segmentedlist>

  </sect2>

  <sect2 role="installation">
    <title>安装 GCC</title>

    <para>晚于 4.3 版本的 GCC 会将此次编制作为重新定位编译器来对待，不会允许在 <parameter>--prefix</parameter> 指定的位置搜索起始文件。由于这不是重新定位编译器，而 <filename class="directory">/tools</filename> 中的起始文件对于编制一个链接至 <filename class="directory">/tools</filename> 中的库的编译器至关重要，所以应用以下补丁暂时将 GCC 还原到旧的行为：</para>

<screen><userinput remap="pre">patch -Np1 -i ../&gcc-startfiles-patch;</userinput></screen>

    <para>通常情况下 GCC <command>fixincludes</command> 脚本会被运行，来修复潜在损坏的头文件。由于现在 GCC-&gcc-version; 和 Glibc-&glibc-version; 已经安装好了，它们的头文件都已知不需要修复，就不需要运行 <command>fixincludes</command> 脚本。事实上，运行这个脚本可能会从宿主系统向 GCC 的私有包含目录安装修复的头文件而污染编制环境。可以执行以下命令来支持运行 <command>fixincludes</command> 脚本：</para>

<screen><userinput remap="pre">cp -v gcc/Makefile.in{,.orig}
sed 's@\./fixinc\.sh@-c true@' gcc/Makefile.in.orig &gt; gcc/Makefile.in</userinput></screen>

    <para>对于 x86 计算机，引导编制 GCC 使用 <option>-fomit-frame-pointer</option> 编译器标记。非引导编制默认会忽略这个标记，而我们的目标是产生一个和引导过完全一样的编译器。应用以下的 <command>sed</command> 命令强制编制使用这个标记：</para> 

<screen><userinput remap="pre">cp -v gcc/Makefile.in{,.tmp}
sed 's/^T_CFLAGS =$/&amp; -fomit-frame-pointer/' gcc/Makefile.in.tmp \
  &gt; gcc/Makefile.in</userinput></screen>

    <para>以下命令将改变 GCC 的默认动态链接器位置以使用安装于 <filename class="directory">/tools</filename> 的那一个。它也会从 GCC 的包含搜索路径中移除 <filename class="directory">/usr/include</filename>。现在就这样做而不是安装后调节 specs 文件是为了确保实际编制 GCC 的过程中使用新的动态链接器。执行：</para>

<screen><userinput remap="pre">for file in \
 $(find gcc/config -name linux64.h -o -name linux.h -o -name sysv4.h)
do
  cp -uv $file{,.orig}
  sed -e 's@/lib\(64\)\?\(32\)\?/ld@/tools&amp;@g' \
  -e 's@/usr@/tools@g' $file.orig &gt; $file
  echo '
#undef STANDARD_INCLUDE_DIR
#define STANDARD_INCLUDE_DIR 0
#define STANDARD_STARTFILE_PREFIX_1 ""
#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file
  touch $file.orig
done</userinput></screen>

    <para>由于上文似乎很难跟进，我们把它拆解开来。首先我们找到 <filename class="directory">gcc/config</filename> 目录中所有名为 <filename>linux.h</filename>、<filename>linux64.h</filename> 或者 <filename>sysv4.h</filename> 的文件。对于找到的每个文件，我们把它复制为一个有同样名字但是加上 <quote>.orig</quote> 后缀。然后第一个 sed 表达式将出现的所有 <quote>/lib/ld</quote>、<quote>/lib64/ld</quote> 或 <quote>/lib32/ld</quote> 替换为 <quote>/tools</quote>，第二个替换硬编码的 <quote>/usr</quote>。然后我们在文件末尾添加我们的声明，调节包含搜索路径和起始文件前缀。最后我们用 <command>touch</command> 来更新复制的文件的时间戳。在与 <command>cp -u</command> 联用时这可以防止由于误操作将命令运行两次而改变原有文件。</para>

    <para>在 x86_64 上，给 GCC 解除多重库 specs 可以确保它不会试图链接至宿主上的库：</para>

<screen><userinput remap="pre">case $(uname -m) in
  x86_64)
    for file in $(find gcc/config -name t-linux64) ; do \
      cp -v $file{,.orig}
      sed '/MULTILIB_OSDIRNAMES/d' $file.orig &gt; $file
    done
  ;;
esac</userinput></screen>

    <para>与第一次编译 GCC 相同，它需要 GMP、MPFR 和 MPC 程序包。解开压缩包冰将它们移动到指定名称的目录中：</para>

<screen><userinput remap="pre">tar -jxf ../mpfr-&mpfr-version;.tar.bz2
mv -v mpfr-&mpfr-version; mpfr
tar -Jxf ../gmp-&gmp-version;.tar.xz
mv -v gmp-&gmp-version; gmp
tar -zxf ../mpc-&mpc-version;.tar.gz
mv -v mpc-&mpc-version; mpc</userinput></screen>

    <para>再创建一个独立的编制目录：</para>

<screen><userinput remap="pre">mkdir -v ../gcc-build
cd ../gcc-build</userinput></screen>

    <para>在开始编制 GCC 之前，记得解除所有覆盖默认调节标记的环境变量。</para>

    <para>现在准备编译 GCC：</para>

<screen><userinput remap="configure">CC="$LFS_TGT-gcc -B/tools/lib/" \
AR=$LFS_TGT-ar                  \
RANLIB=$LFS_TGT-ranlib          \
../gcc-&gcc-version;/configure          \
    --prefix=/tools             \
    --with-local-prefix=/tools  \
    --enable-clocale=gnu        \
    --enable-shared             \
    --enable-threads=posix      \
    --enable-__cxa_atexit       \
    --enable-languages=c,c++    \
    --disable-libstdcxx-pch     \
    --disable-multilib          \
    --disable-bootstrap         \
    --disable-libgomp           \
    --without-ppl               \
    --without-cloog             \
    --with-mpfr-include=$(pwd)/../gcc-&gcc-version;/mpfr/src \
    --with-mpfr-lib=$(pwd)/mpfr/src/.libs</userinput></screen>

    <variablelist>
      <title>新配置脚本的含义：</title>

      <varlistentry>
        <term><parameter>--enable-clocale=gnu</parameter></term>
        <listitem>
          <para>This option ensures the correct locale model is selected
          for the C++ libraries under all circumstances. If the configure
          script finds the <emphasis>de_DE</emphasis> locale installed,
          it will select the correct gnu locale model. However, if the
          <emphasis>de_DE</emphasis> locale is not installed, there is the
          risk of building Application Binary Interface (ABI)-incompatible
          C++ libraries because the incorrect generic locale model may be
          selected.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><parameter>--enable-threads=posix</parameter></term>
        <listitem>
          <para>This enables C++ exception handling for multi-threaded code.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><parameter>--enable-__cxa_atexit</parameter></term>
        <listitem>
          <para>This option allows use of <function>__cxa_atexit</function>,
          rather than <function>atexit</function>, to register C++ destructors
          for local statics and global objects. This option is essential for
          fully standards-compliant handling of destructors. It also affects
          the C++ ABI, and therefore results in C++ shared libraries and C++
          programs that are interoperable with other Linux distributions.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><parameter>--enable-languages=c,c++</parameter></term>
        <listitem>
          <para>This option ensures that both the C and C++ compilers are
          built.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><parameter>--disable-libstdcxx-pch</parameter></term>
        <listitem>
          <para>Do not build the pre-compiled header (PCH) for
          <filename class="libraryfile">libstdc++</filename>. It takes up a
          lot of space, and we have no use for it.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><parameter>--disable-bootstrap</parameter></term>
        <listitem>
          <para>For native builds of GCC, the default is to do a "bootstrap"
          build. This does not just compile GCC, but compiles it several times.
          It uses the programs compiled in a first round to compile itself a
          second time, and then again a third time.  The second and third
          iterations are compared to make sure it can reproduce itself
          flawlessly. This also implies that it was compiled correctly.
          However, the LFS build method should provide a solid compiler
          without the need to bootstrap each time.</para> 
        </listitem>
      </varlistentry>

    </variablelist>

    <para>Compile the package:</para>

<screen><userinput remap="make">make</userinput></screen>

    <para>Install the package:</para>

<screen><userinput remap="install">make install</userinput></screen>

    <para>As a finishing touch, create a symlink. Many programs and scripts
    run <command>cc</command> instead of <command>gcc</command>, which is
    used to keep programs generic and therefore usable on all kinds of UNIX
    systems where the GNU C compiler is not always installed. Running
    <command>cc</command> leaves the system administrator free to decide
    which C compiler to install:</para>

<screen><userinput remap="install">ln -vs gcc /tools/bin/cc</userinput></screen>

  <caution>
    <para>At this point, it is imperative to stop and ensure that the basic
    functions (compiling and linking) of the new toolchain are working as
    expected. To perform a sanity check, run the following commands:</para>

<screen><userinput>echo 'main(){}' &gt; dummy.c
cc dummy.c
readelf -l a.out | grep ': /tools'</userinput></screen>

    <para>If everything is working correctly, there should be no errors,
    and the output of the last command will be of the form:</para>

<screen><computeroutput>[Requesting program interpreter: /tools/lib/ld-linux.so.2]</computeroutput></screen>

    <para>Note that <filename class="directory">/tools/lib</filename>, or
    <filename class="directory">/tools/lib64</filename> for 64-bit machines
    appears as the prefix of the dynamic linker.</para>

    <para>If the output is not shown as above or there was no output at all,
    then something is wrong. Investigate and retrace the steps to find out
    where the problem is and correct it. This issue must be resolved before
    continuing on. First, perform the sanity check again, using
    <command>gcc</command> instead of <command>cc</command>. If this works,
    then the <filename class="symlink">/tools/bin/cc</filename> symlink is
    missing. Install the symlink as per above.
    Next, ensure that the <envar>PATH</envar> is correct. This
    can be checked by running <command>echo $PATH</command> and verifying that
    <filename class="directory">/tools/bin</filename> is at the head of the
    list. If the <envar>PATH</envar> is wrong it could mean that you are not
    logged in as user <systemitem class="username">lfs</systemitem> or that
    something went wrong back in <xref linkend="ch-tools-settingenviron"
    role="."/></para>

    <para>Once all is well, clean up the test files:</para>

<screen><userinput>rm -v dummy.c a.out</userinput></screen>

  </caution>

  </sect2>

  <sect2 role="content">
    <title/>

    <para>Details on this package are located in
    <xref linkend="contents-gcc" role="."/></para>

  </sect2>

</sect1>
