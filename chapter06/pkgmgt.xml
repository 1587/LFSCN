<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-pkgmgt">
  <?dbhtml filename="pkgmgt.html"?>

  <title>程序包管理</title>

  <para>经常有人要求向 LFS 中加入程序包管理。程序包管理器允许跟踪文件的安装，使得移除和升级程序包变得容易。程序包管理器不仅会处理二进制和库文件，还会处理配置文件的安装。不要纠结&mdash;这一节既不会讲解也不会推荐任何一个程序包管理器。我们只是概述一下热门的技巧及其工作方式。对你来说完美的包管理器可能就在其中或者是其中几种的组合。这一节简要提及升级程序包时可能出现的问题。</para>

  <para>LFS 或者 BLFS 中不提及程序包管理器的原因包括：</para>

  <itemizedlist>
    <listitem>
      <para>进行程序包管理会减少对本书目标&mdash;&mdash;讲解 Linux 系统如何搭建&mdash;&mdash;的关注。</para>
    </listitem>

    <listitem>
      <para>程序包管理有多种解决方案，它们有各自的强项和缺点。要选出一个来满足所有读者十分困难。</para>
    </listitem>
  </itemizedlist>

  <para>有关程序包管理有一些提示。访问 <ulink url="&hints-index;">Hints 工程</ulink> 看看能否满足你的需求。</para>

  <sect2>
    <title>升级问题</title>

    <para>程序包管理器使得在新版本发布时升级更简单。通常可以使用 LFS 和 BLFS 中的指令来升级到新版本。以下是在升级程序包，尤其是在运行的系统上如此做时需要注意的事项。</para>

    <itemizedlist>
      <listitem>
        <para>如果工具链程序包之一 (Glibc、GCC 或 Binutils) 需要升级到一个新的小版本，重新编制 LFS 会更安全。虽然你<emphasis>可能</emphasis>能够通过按照依赖关系顺序重新编制所有程序包来解决问题，我们并不推荐这种方式。例如要升级 glibc-2.2.x 到 glibc-2.3.x，重新编制更加安全。对于微小版本升级，简单地重新安装通常就能工作，但是只是通常。例如将 glibc-2.3.4 升级为 glibc-2.3.5 通常不会产生任何问题。</para>
      </listitem>

      <listitem>
        <para>如果一个包含共享库的程序包升级了并且库的名称改变，那么所有动态链接到这个库的程序包都要重新编译以链接到新的库。(注意程序包版本和库名称之间并没有必然联系。) 例如，假设程序包 foo-1.2.3 安装的共享库名为 <filename class='libraryfile'>libfoo.so.1</filename>。其新版本 foo-1.2.4 将安装的共享库名为 <filename class='libraryfile'>libfoo.so.2</filename>。这种情况下所有动态链接到 <filename class='libraryfile'>libfoo.so.1</filename> 的程序包都要重新编译以链接到 <filename class='libraryfile'>libfoo.so.2</filename>。注意，在所有的依赖程序包重新编译完成之前你不应该移除先前的库。</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>程序包管理技巧</title>

    <para>以下是一些常见的程序包管理技巧。在选择程序包管理器之前，了解一下不同技巧，尤其是它们的缺点。</para>

    <sect3>
      <title>我自己能够搞定！</title>

      <para>是的，这也是一种程序包管理技巧。有些人因为非常了解程序包，知道每个包安装了什么文件所以不需要程序包管理器。还有一些用户也不需要程序包管理，因为他们打算在有程序包改动的时候重新编制整个系统。</para>

    </sect3>

    <sect3>
      <title>安装到分立目录中</title>

      <para>这是一种简单的程序包管理方式，不需要额外的程序包来管理安装。每个程序包安装于一个独立的目录中。例如，程序包 foo-1.1 安装于  <filename class='directory'>/usr/pkg/foo-1.1</filename> 中，并且创建一个由  <filename>/usr/pkg/foo</filename> 到 <filename class='directory'>/usr/pkg/foo-1.1</filename> 的符号链接。安装新的版本 foo-1.2 时，它安装于 <filename class='directory'>/usr/pkg/foo-1.2</filename> 中，之前的符号链接被替换成到新版本的符号链接。</para>

      <para>环境变量，比如 <envar>PATH</envar>、<envar>LD_LIBRARY_PATH</envar>、<envar>MANPATH</envar>、<envar>INFOPATH</envar> 和 <envar>CPPFLAGS</envar> 需要扩展以包括 <filename>/usr/pkg/foo</filename>。如果程序包很多，这种方法就很难管理。</para>

    </sect3>

    <sect3>
      <title>符号链接式程序包管理</title>

      <para>这是前一种程序包管理技巧的一种变化。每个程序包安装的方式与前一种方式相同，但并不建立符号链接而是链接到 <filename class='directory'>/usr</filename> 目录中。这样就不必扩展环境变量。虽然符号链接可以由用户创建，仍然有很多程序包管理器使用这种方式工作。其中比较流行的包括 Stow、Epkg、Graft和 Depot。</para>

      <para>因为安装需要伪装，所以程序包认为被安装到了 <filename class="directory">/usr</filename> 却实际被安装到了 <filename class="directory">/usr/pkg</filename> 目录中。以这种方式安装通常不是什么普通的任务。例如要安装 libfoo-1.1 这个程序包。以下指令可能无法正确安装之：</para>

<screen role="nodump"><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>

      <para>安装能够工作，但是依赖的程序包可能不会像你期待的那样链接到 libfoo。如果你编译一个链接到 libfoo 的程序包，你会发现它链接到 <filename class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> 而不是你期待的 <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename>。正确的方式是使用 <envar>DESTDIR</envar> 策略伪装该程序包的安装。这种方式如此工作：</para>

<screen role="nodump"><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>

      <para>多数程序包都支持这种方式，但也存在不支持的。对于不支持的程序包，你可以手动安装之，但将这种麻烦的程序包安装至 <filename class='directory'>/opt</filename> 中会更简单。</para>

    </sect3>

    <sect3>
      <title>Timestamp Based</title>

      <para>In this technique, a file is timestamped before the installation of
      the package. After the installation, a simple use of the
      <command>find</command> command with the appropriate options can generate
      a log of all the files installed after the timestamp file was created. A
      package manager written with this approach is install-log.</para>

      <para>Though this scheme has the advantage of being simple, it has two
      drawbacks. If, during installation, the files are installed with any
      timestamp other than the current time, those files will not be tracked by
      the package manager. Also, this scheme can only be used when one package
      is installed at a time. The logs are not reliable if two packages are
      being installed on two different consoles.</para>

    </sect3>

    <sect3>
      <title>Tracing Installation Scripts</title>

      <para>In this approach, the commands that the installation scripts perform
      are recorded.  There are two techniques that one can use:</para>

      <para>The <envar>LD_PRELOAD</envar> environment variable can be set to
      point to a library to be preloaded before installation.  During
      installation, this library tracks the packages that are being installed by
      attaching itself to various executables such as <command>cp</command>,
      <command>install</command>, <command>mv</command> and tracking the system
      calls that modify the filesystem. For this approach to work, all the
      executables need to be dynamically linked without the suid or sgid bit.
      Preloading the library may cause some unwanted side-effects during
      installation. Therefore, it is advised that one performs some tests to
      ensure that the package manager does not break anything and logs all the
      appropriate files.</para>

      <para>The second technique is to use <command>strace</command>, which
      logs all system calls made during the execution of the installation
      scripts.</para>
    </sect3>

    <sect3>
      <title>Creating Package Archives</title>

      <para>In this scheme, the package installation is faked into a separate
      tree as described in the Symlink style package management. After the
      installation, a package archive is created using the installed files.
      This archive is then used to install the package either on the local
      machine or can even be used to install the package on other machines.</para>

      <para>This approach is used by most of the package managers found in the
      commercial distributions. Examples of package managers that follow this
      approach are RPM (which, incidentally, is required by the <ulink
      url="http://www.linux-foundation.org/en/Specifications">Linux
      Standard Base Specification</ulink>), pkg-utils, Debian's apt, and
      Gentoo's Portage system.  A hint describing how to adopt this style of
      package management for LFS systems is located at <ulink
      url="&hints-root;fakeroot.txt"/>.</para>

      <para>Creation of package files that include dependency information is
      complex and is beyond the scope of LFS.</para>

      <para>Slackware uses a <command>tar</command> based system for package 
      archives.  This system purposely does not handle package dependencies
      as more complex package managers do.  For details of Slackware package
      management, see <ulink
      url="http://www.slackbook.org/html/package-management.html"/>.</para>
    </sect3>

    <sect3>
      <title>User Based Management</title>

      <para>This scheme, unique to LFS, was devised by Matthias Benkmann, and is
      available from the <ulink url="&hints-index;">Hints Project</ulink>. In
      this scheme, each package is installed as a separate user into the
      standard locations. Files belonging to a package are easily identified by
      checking the user ID. The features and shortcomings of this approach are
      too complex to describe in this section. For the details please see the
      hint at <ulink url="&hints-root;more_control_and_pkg_man.txt"/>.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Deploying LFS on Multiple Systems</title>

    <para>One of the advantages of an LFS system is that there are no files that
    depend on the position of files on a disk system.  Cloning an LFS build to
    another computer with an architecture similar to the base system is as
    simple as using <command>tar</command> on the LFS partition that contains
    the root directory (about 250MB uncompressed for a base LFS build), copying
    that file via network transfer or CD-ROM to the new system and expanding
    it.  From that point, a few configuration files will have to be changed.
    Configuration files that may need to be updated include: 
    <filename>/etc/hosts</filename>,
    <filename>/etc/fstab</filename>,
    <filename>/etc/passwd</filename>,
    <filename>/etc/group</filename>,
    <filename>/etc/shadow</filename>,
    <filename>/etc/ld.so.conf</filename>,
    <filename>/etc/scsi_id.config</filename>,
    <filename>/etc/sysconfig/network</filename> and
    <filename>/etc/sysconfig/network-devices/ifconfig.eth0/ipv4</filename>.    
    </para>

    <para>A custom kernel may need to be built for the new system depending on
    differences in system hardware and the original kernel
    configuration.</para>

    <para>Finally the new system has to be made bootable via <xref
    linkend="ch-bootable-grub"/>.</para>

  </sect2>

</sect1>
