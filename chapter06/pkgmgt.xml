<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-pkgmgt">
  <?dbhtml filename="pkgmgt.html"?>

  <title>程序包管理</title>

  <para>经常有人要求向 LFS 中加入程序包管理。程序包管理器允许跟踪文件的安装，使得移除和升级程序包变得容易。程序包管理器不仅会处理二进制和库文件，还会处理配置文件的安装。不要纠结&mdash;这一节既不会讲解也不会推荐任何一个程序包管理器。我们只是概述一下热门的技巧及其工作方式。对你来说完美的包管理器可能就在其中或者是其中几种的组合。这一节简要提及升级程序包时可能出现的问题。</para>

  <para>LFS 或者 BLFS 中不提及程序包管理器的原因包括：</para>

  <itemizedlist>
    <listitem>
      <para>进行程序包管理会减少对本书目标&mdash;讲解 Linux 系统如何搭建&mdash;的关注。</para>
    </listitem>

    <listitem>
      <para>程序包管理有多种解决方案，它们有各自的强项和缺点。要选出一个来满足所有读者十分困难。</para>
    </listitem>
  </itemizedlist>

  <para>有关程序包管理有一些提示。访问 <ulink url="&hints-index;">Hints 工程</ulink> 看看能否满足你的需求。</para>

  <sect2>
    <title>升级问题</title>

    <para>程序包管理器使得在新版本发布时升级更简单。通常可以使用 LFS 和 BLFS 中的指令来升级到新版本。以下是在升级程序包，尤其是在运行的系统上如此做时需要注意的事项。</para>

    <itemizedlist>
      <listitem>
        <para>如果工具链程序包之一 (Glibc、GCC 或 Binutils) 需要升级到一个新的小版本，重新编制 LFS 会更安全。虽然你<emphasis>可能</emphasis>能够通过按照依赖关系顺序重新编制所有程序包来解决问题，我们并不推荐这种方式。例如要升级 glibc-2.2.x 到 glibc-2.3.x，重新编制更加安全。对于微小版本升级，简单地重新安装通常就能工作，但是只是通常。例如将 glibc-2.3.4 升级为 glibc-2.3.5 通常不会产生任何问题。</para>
      </listitem>

      <listitem>
        <para>如果一个包含共享库的程序包升级了并且库的名称改变，那么所有动态链接到这个库的程序包都要重新编译以链接到新的库。(注意程序包版本和库名称之间并没有必然联系。) 例如，假设程序包 foo-1.2.3 安装的共享库名为 <filename class='libraryfile'>libfoo.so.1</filename>。其新版本 foo-1.2.4 将安装的共享库名为 <filename class='libraryfile'>libfoo.so.2</filename>。这种情况下所有动态链接到 <filename class='libraryfile'>libfoo.so.1</filename> 的程序包都要重新编译以链接到 <filename class='libraryfile'>libfoo.so.2</filename>。注意，在所有的依赖程序包重新编译完成之前你不应该移除先前的库。</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>程序包管理技巧</title>

    <para>以下是一些常见的程序包管理技巧。在选择程序包管理器之前，了解一下不同技巧，尤其是它们的缺点。</para>

    <sect3>
      <title>我自己能够搞定！</title>

      <para>是的，这也是一种程序包管理技巧。有些人因为非常了解程序包，知道每个包安装了什么文件所以不需要程序包管理器。还有一些用户也不需要程序包管理，因为他们打算在有程序包改动的时候重新编制整个系统。</para>

    </sect3>

    <sect3>
      <title>安装到分立目录中</title>

      <para>This is a simplistic package management that does not need any extra
      package to manage the installations. Each package is installed in a
      separate directory. For example, package foo-1.1 is installed in
      <filename class='directory'>/usr/pkg/foo-1.1</filename>
      and a symlink is made from <filename>/usr/pkg/foo</filename> to
      <filename class='directory'>/usr/pkg/foo-1.1</filename>. When installing
      a new version foo-1.2, it is installed in
      <filename class='directory'>/usr/pkg/foo-1.2</filename> and the previous
      symlink is replaced by a symlink to the new version.</para>

      <para>Environment variables such as <envar>PATH</envar>,
      <envar>LD_LIBRARY_PATH</envar>, <envar>MANPATH</envar>,
      <envar>INFOPATH</envar> and <envar>CPPFLAGS</envar> need to be expanded to
      include <filename>/usr/pkg/foo</filename>. For more than a few packages,
      this scheme becomes unmanageable.</para>

    </sect3>

    <sect3>
      <title>Symlink Style Package Management</title>

      <para>This is a variation of the previous package management technique.
      Each package is installed similar to the previous scheme. But instead of
      making the symlink, each file is symlinked into the
      <filename class='directory'>/usr</filename> hierarchy. This removes the
      need to expand the environment variables. Though the symlinks can be
      created by the user to automate the creation, many package managers have
      been written using this approach. A few of the popular ones include Stow,
      Epkg, Graft, and Depot.</para>

      <para>The installation needs to be faked, so that the package thinks that
      it is installed in <filename class="directory">/usr</filename> though in
      reality it is installed in the
      <filename class="directory">/usr/pkg</filename> hierarchy. Installing in
      this manner is not usually a trivial task. For example, consider that you
      are installing a package libfoo-1.1. The following instructions may
      not install the package properly:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>

      <para>The installation will work, but the dependent packages may not link
      to libfoo as you would expect. If you compile a package that links against
      libfoo, you may notice that it is linked to
      <filename class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename>
      instead of <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename>
      as you would expect. The correct approach is to use the
      <envar>DESTDIR</envar> strategy to fake installation of the package. This
      approach works as follows:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>

      <para>Most packages support this approach, but there are some which do not.
      For the non-compliant packages, you may either need to manually install the
      package, or you may find that it is easier to install some problematic
      packages into <filename class='directory'>/opt</filename>.</para>

    </sect3>

    <sect3>
      <title>Timestamp Based</title>

      <para>In this technique, a file is timestamped before the installation of
      the package. After the installation, a simple use of the
      <command>find</command> command with the appropriate options can generate
      a log of all the files installed after the timestamp file was created. A
      package manager written with this approach is install-log.</para>

      <para>Though this scheme has the advantage of being simple, it has two
      drawbacks. If, during installation, the files are installed with any
      timestamp other than the current time, those files will not be tracked by
      the package manager. Also, this scheme can only be used when one package
      is installed at a time. The logs are not reliable if two packages are
      being installed on two different consoles.</para>

    </sect3>

    <sect3>
      <title>Tracing Installation Scripts</title>

      <para>In this approach, the commands that the installation scripts perform
      are recorded.  There are two techniques that one can use:</para>

      <para>The <envar>LD_PRELOAD</envar> environment variable can be set to
      point to a library to be preloaded before installation.  During
      installation, this library tracks the packages that are being installed by
      attaching itself to various executables such as <command>cp</command>,
      <command>install</command>, <command>mv</command> and tracking the system
      calls that modify the filesystem. For this approach to work, all the
      executables need to be dynamically linked without the suid or sgid bit.
      Preloading the library may cause some unwanted side-effects during
      installation. Therefore, it is advised that one performs some tests to
      ensure that the package manager does not break anything and logs all the
      appropriate files.</para>

      <para>The second technique is to use <command>strace</command>, which
      logs all system calls made during the execution of the installation
      scripts.</para>
    </sect3>

    <sect3>
      <title>Creating Package Archives</title>

      <para>In this scheme, the package installation is faked into a separate
      tree as described in the Symlink style package management. After the
      installation, a package archive is created using the installed files.
      This archive is then used to install the package either on the local
      machine or can even be used to install the package on other machines.</para>

      <para>This approach is used by most of the package managers found in the
      commercial distributions. Examples of package managers that follow this
      approach are RPM (which, incidentally, is required by the <ulink
      url="http://www.linux-foundation.org/en/Specifications">Linux
      Standard Base Specification</ulink>), pkg-utils, Debian's apt, and
      Gentoo's Portage system.  A hint describing how to adopt this style of
      package management for LFS systems is located at <ulink
      url="&hints-root;fakeroot.txt"/>.</para>

      <para>Creation of package files that include dependency information is
      complex and is beyond the scope of LFS.</para>

      <para>Slackware uses a <command>tar</command> based system for package 
      archives.  This system purposely does not handle package dependencies
      as more complex package managers do.  For details of Slackware package
      management, see <ulink
      url="http://www.slackbook.org/html/package-management.html"/>.</para>
    </sect3>

    <sect3>
      <title>User Based Management</title>

      <para>This scheme, unique to LFS, was devised by Matthias Benkmann, and is
      available from the <ulink url="&hints-index;">Hints Project</ulink>. In
      this scheme, each package is installed as a separate user into the
      standard locations. Files belonging to a package are easily identified by
      checking the user ID. The features and shortcomings of this approach are
      too complex to describe in this section. For the details please see the
      hint at <ulink url="&hints-root;more_control_and_pkg_man.txt"/>.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Deploying LFS on Multiple Systems</title>

    <para>One of the advantages of an LFS system is that there are no files that
    depend on the position of files on a disk system.  Cloning an LFS build to
    another computer with an architecture similar to the base system is as
    simple as using <command>tar</command> on the LFS partition that contains
    the root directory (about 250MB uncompressed for a base LFS build), copying
    that file via network transfer or CD-ROM to the new system and expanding
    it.  From that point, a few configuration files will have to be changed.
    Configuration files that may need to be updated include: 
    <filename>/etc/hosts</filename>,
    <filename>/etc/fstab</filename>,
    <filename>/etc/passwd</filename>,
    <filename>/etc/group</filename>,
    <filename>/etc/shadow</filename>,
    <filename>/etc/ld.so.conf</filename>,
    <filename>/etc/scsi_id.config</filename>,
    <filename>/etc/sysconfig/network</filename> and
    <filename>/etc/sysconfig/network-devices/ifconfig.eth0/ipv4</filename>.    
    </para>

    <para>A custom kernel may need to be built for the new system depending on
    differences in system hardware and the original kernel
    configuration.</para>

    <para>Finally the new system has to be made bootable via <xref
    linkend="ch-bootable-grub"/>.</para>

  </sect2>

</sect1>
