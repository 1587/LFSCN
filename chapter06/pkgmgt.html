<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      6.3.&nbsp;程序包管理
    </title>
    <link rel="stylesheet" href="../stylesheets/lfs.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
  </head>
  <body class="lfs" id="lfs-SVN-20120827">
    <div class="navheader">
      <h4>
        Linux From Scratch - 版本 SVN-20120827
      </h4>
      <h3>
        第&nbsp;6&nbsp;章&nbsp;安装基本系统软件
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="kernfs.html" title="准备虚拟内核文件系统">上一页</a>
          <p>
            准备虚拟内核文件系统
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="chroot.html" title=
          "Entering the Chroot Environment">下一页</a>
          <p>
            Entering the Chroot Environment
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter06.html" title=
          "第&nbsp;6&nbsp;章&nbsp;安装基本系统软件">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 SVN-20120827">起始页</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="zh-cn" xml:lang="zh-cn">
      <h1 class="sect1">
        <a id="ch-system-pkgmgt" name="ch-system-pkgmgt"></a>6.3. 程序包管理
      </h1>
      <p>
        经常有人要求向 LFS
        中加入程序包管理。程序包管理器允许跟踪文件的安装，使得移除和升级程序包变得容易。程序包管理器不仅会处理二进制和库文件，还会处理配置文件的安装。不要纠结—这一节既不会讲解也不会推荐任何一个程序包管理器。我们只是概述一下热门的技巧及其工作方式。对你来说完美的包管理器可能就在其中或者是其中几种的组合。这一节简要提及升级程序包时可能出现的问题。
      </p>
      <p>
        LFS 或者 BLFS 中不提及程序包管理器的原因包括：
      </p>
      <div class="itemizedlist">
        <ul>
          <li>
            <p>
              进行程序包管理会减少对本书目标——讲解 Linux 系统如何搭建——的关注。
            </p>
          </li>
          <li>
            <p>
              程序包管理有多种解决方案，它们有各自的强项和缺点。要选出一个来满足所有读者十分困难。
            </p>
          </li>
        </ul>
      </div>
      <p>
        有关程序包管理有一些提示。访问 <a class="ulink" href=
        "http://www.linuxfromscratch.org/hints/list.html">Hints 工程</a>
        看看能否满足你的需求。
      </p>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          6.3.1. 升级问题
        </h2>
        <p>
          程序包管理器使得在新版本发布时升级更简单。通常可以使用 LFS 和 BLFS
          中的指令来升级到新版本。以下是在升级程序包，尤其是在运行的系统上如此做时需要注意的事项。
        </p>
        <div class="itemizedlist">
          <ul>
            <li>
              <p>
                如果工具链程序包之一 (Glibc、GCC 或 Binutils) 需要升级到一个新的小版本，重新编制 LFS
                会更安全。虽然你<span class=
                "emphasis"><em>可能</em></span>能够通过按照依赖关系顺序重新编制所有程序包来解决问题，我们并不推荐这种方式。例如要升级
                glibc-2.2.x 到
                glibc-2.3.x，重新编制更加安全。对于微小版本升级，简单地重新安装通常就能工作，但是只是通常。例如将
                glibc-2.3.4 升级为 glibc-2.3.5 通常不会产生任何问题。
              </p>
            </li>
            <li>
              <p>
                如果一个包含共享库的程序包升级了并且库的名称改变，那么所有动态链接到这个库的程序包都要重新编译以链接到新的库。(注意程序包版本和库名称之间并没有必然联系。)
                例如，假设程序包 foo-1.2.3 安装的共享库名为 <code class=
                "filename">libfoo.so.1</code>。其新版本 foo-1.2.4 将安装的共享库名为
                <code class="filename">libfoo.so.2</code>。这种情况下所有动态链接到
                <code class="filename">libfoo.so.1</code> 的程序包都要重新编译以链接到
                <code class=
                "filename">libfoo.so.2</code>。注意，在所有的依赖程序包重新编译完成之前你不应该移除先前的库。
              </p>
            </li>
          </ul>
        </div>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          6.3.2. 程序包管理技巧
        </h2>
        <p>
          以下是一些常见的程序包管理技巧。在选择程序包管理器之前，了解一下不同技巧，尤其是它们的缺点。
        </p>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            6.3.2.1. 我自己能够搞定！
          </h3>
          <p>
            是的，这也是一种程序包管理技巧。有些人因为非常了解程序包，知道每个包安装了什么文件所以不需要程序包管理器。还有一些用户也不需要程序包管理，因为他们打算在有程序包改动的时候重新编制整个系统。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            6.3.2.2. 安装到分立目录中
          </h3>
          <p>
            这是一种简单的程序包管理方式，不需要额外的程序包来管理安装。每个程序包安装于一个独立的目录中。例如，程序包 foo-1.1 安装于
            <code class="filename">/usr/pkg/foo-1.1</code> 中，并且创建一个由
            <code class="filename">/usr/pkg/foo</code> 到 <code class=
            "filename">/usr/pkg/foo-1.1</code> 的符号链接。安装新的版本 foo-1.2 时，它安装于
            <code class="filename">/usr/pkg/foo-1.2</code>
            中，之前的符号链接被替换成到新版本的符号链接。
          </p>
          <p>
            环境变量，比如 <code class="envar">PATH</code>、<code class=
            "envar">LD_LIBRARY_PATH</code>、<code class=
            "envar">MANPATH</code>、<code class="envar">INFOPATH</code> 和
            <code class="envar">CPPFLAGS</code> 需要扩展以包括 <code class=
            "filename">/usr/pkg/foo</code>。如果程序包很多，这种方法就很难管理。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            6.3.2.3. 符号链接式程序包管理
          </h3>
          <p>
            这是前一种程序包管理技巧的一种变化。每个程序包安装的方式与前一种方式相同，但并不建立符号链接而是链接到 <code class=
            "filename">/usr</code>
            目录中。这样就不必扩展环境变量。虽然符号链接可以由用户创建，仍然有很多程序包管理器使用这种方式工作。其中比较流行的包括
            Stow、Epkg、Graft和 Depot。
          </p>
          <p>
            因为安装需要伪装，所以程序包认为被安装到了 <code class="filename">/usr</code> 却实际被安装到了
            <code class="filename">/usr/pkg</code>
            目录中。以这种方式安装通常不是什么普通的任务。例如要安装 libfoo-1.1 这个程序包。以下指令可能无法正确安装之：
          </p>
          <pre class="userinput">
<kbd class="command">./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</kbd>
</pre>
          <p>
            安装能够工作，但是依赖的程序包可能不会像你期待的那样链接到 libfoo。如果你编译一个链接到 libfoo
            的程序包，你会发现它链接到 <code class=
            "filename">/usr/pkg/libfoo/1.1/lib/libfoo.so.1</code> 而不是你期待的
            <code class="filename">/usr/lib/libfoo.so.1</code>。正确的方式是使用
            <code class="envar">DESTDIR</code> 策略伪装该程序包的安装。这种方式如此工作：
          </p>
          <pre class="userinput">
<kbd class="command">./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</kbd>
</pre>
          <p>
            多数程序包都支持这种方式，但也存在不支持的。对于不支持的程序包，你可以手动安装之，但将这种麻烦的程序包安装至
            <code class="filename">/opt</code> 中会更简单。
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            6.3.2.4. Timestamp Based
          </h3>
          <p>
            In this technique, a file is timestamped before the installation
            of the package. After the installation, a simple use of the
            <span class="command"><strong>find</strong></span> command with
            the appropriate options can generate a log of all the files
            installed after the timestamp file was created. A package manager
            written with this approach is install-log.
          </p>
          <p>
            Though this scheme has the advantage of being simple, it has two
            drawbacks. If, during installation, the files are installed with
            any timestamp other than the current time, those files will not
            be tracked by the package manager. Also, this scheme can only be
            used when one package is installed at a time. The logs are not
            reliable if two packages are being installed on two different
            consoles.
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            6.3.2.5. Tracing Installation Scripts
          </h3>
          <p>
            In this approach, the commands that the installation scripts
            perform are recorded. There are two techniques that one can use:
          </p>
          <p>
            The <code class="envar">LD_PRELOAD</code> environment variable
            can be set to point to a library to be preloaded before
            installation. During installation, this library tracks the
            packages that are being installed by attaching itself to various
            executables such as <span class=
            "command"><strong>cp</strong></span>, <span class=
            "command"><strong>install</strong></span>, <span class=
            "command"><strong>mv</strong></span> and tracking the system
            calls that modify the filesystem. For this approach to work, all
            the executables need to be dynamically linked without the suid or
            sgid bit. Preloading the library may cause some unwanted
            side-effects during installation. Therefore, it is advised that
            one performs some tests to ensure that the package manager does
            not break anything and logs all the appropriate files.
          </p>
          <p>
            The second technique is to use <span class=
            "command"><strong>strace</strong></span>, which logs all system
            calls made during the execution of the installation scripts.
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            6.3.2.6. Creating Package Archives
          </h3>
          <p>
            In this scheme, the package installation is faked into a separate
            tree as described in the Symlink style package management. After
            the installation, a package archive is created using the
            installed files. This archive is then used to install the package
            either on the local machine or can even be used to install the
            package on other machines.
          </p>
          <p>
            This approach is used by most of the package managers found in
            the commercial distributions. Examples of package managers that
            follow this approach are RPM (which, incidentally, is required by
            the <a class="ulink" href=
            "http://www.linux-foundation.org/en/Specifications">Linux
            Standard Base Specification</a>), pkg-utils, Debian's apt, and
            Gentoo's Portage system. A hint describing how to adopt this
            style of package management for LFS systems is located at
            <a class="ulink" href=
            "http://www.linuxfromscratch.org/hints/downloads/files/fakeroot.txt">
            http://www.linuxfromscratch.org/hints/downloads/files/fakeroot.txt</a>.
          </p>
          <p>
            Creation of package files that include dependency information is
            complex and is beyond the scope of LFS.
          </p>
          <p>
            Slackware uses a <span class=
            "command"><strong>tar</strong></span> based system for package
            archives. This system purposely does not handle package
            dependencies as more complex package managers do. For details of
            Slackware package management, see <a class="ulink" href=
            "http://www.slackbook.org/html/package-management.html">http://www.slackbook.org/html/package-management.html</a>.
          </p>
        </div>
        <div class="sect3" lang="zh-cn" xml:lang="zh-cn">
          <h3 class="sect3">
            6.3.2.7. User Based Management
          </h3>
          <p>
            This scheme, unique to LFS, was devised by Matthias Benkmann, and
            is available from the <a class="ulink" href=
            "http://www.linuxfromscratch.org/hints/list.html">Hints
            Project</a>. In this scheme, each package is installed as a
            separate user into the standard locations. Files belonging to a
            package are easily identified by checking the user ID. The
            features and shortcomings of this approach are too complex to
            describe in this section. For the details please see the hint at
            <a class="ulink" href=
            "http://www.linuxfromscratch.org/hints/downloads/files/more_control_and_pkg_man.txt">
            http://www.linuxfromscratch.org/hints/downloads/files/more_control_and_pkg_man.txt</a>.
          </p>
        </div>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          6.3.3. Deploying LFS on Multiple Systems
        </h2>
        <p>
          One of the advantages of an LFS system is that there are no files
          that depend on the position of files on a disk system. Cloning an
          LFS build to another computer with an architecture similar to the
          base system is as simple as using <span class=
          "command"><strong>tar</strong></span> on the LFS partition that
          contains the root directory (about 250MB uncompressed for a base
          LFS build), copying that file via network transfer or CD-ROM to the
          new system and expanding it. From that point, a few configuration
          files will have to be changed. Configuration files that may need to
          be updated include: <code class="filename">/etc/hosts</code>,
          <code class="filename">/etc/fstab</code>, <code class=
          "filename">/etc/passwd</code>, <code class=
          "filename">/etc/group</code>, <code class=
          "filename">/etc/shadow</code>, <code class=
          "filename">/etc/ld.so.conf</code>, <code class=
          "filename">/etc/scsi_id.config</code>, <code class=
          "filename">/etc/sysconfig/network</code> and <code class=
          "filename">/etc/sysconfig/network-devices/ifconfig.eth0/ipv4</code>.
        </p>
        <p>
          A custom kernel may need to be built for the new system depending
          on differences in system hardware and the original kernel
          configuration.
        </p>
        <p>
          Finally the new system has to be made bootable via <a class="xref"
          href="../chapter08/grub.html" title=
          "8.4.&nbsp;Using GRUB to Set Up the Boot Process">第&nbsp;8.4&nbsp;节
          “Using GRUB to Set Up the Boot Process”</a>.
        </p>
      </div>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="kernfs.html" title="准备虚拟内核文件系统">上一页</a>
          <p>
            准备虚拟内核文件系统
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="chroot.html" title=
          "Entering the Chroot Environment">下一页</a>
          <p>
            Entering the Chroot Environment
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter06.html" title=
          "第&nbsp;6&nbsp;章&nbsp;安装基本系统软件">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 SVN-20120827">起始页</a>
        </li>
      </ul>
    </div>
  </body>
</html>
